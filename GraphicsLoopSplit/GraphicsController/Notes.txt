Now that model loading is started, we want to initiate and manage the load from c#,
and we want the method to load it return an ID that corresponds to its index in a 
global c++ vector of models (which will later be converted to meshes)

More precisely, and perhaps this is what we should first endeavor to do:
We want c++ to return a complex struct that we will intrepret (in c#) as a 
SceneObject, our own variant of the GameObject from Unity.

The SceneObject itself will have an ID that corresponds to its index in a c++ vector,
AND each child mesh of the SceneObject should also possess ID's corresponding to indices.


I've set up model loading from c#. What remains to do is to add a material struct to the mesh class,
and a shader class to the material struct therein. That way, when a mesh is drawn, the sceneObject configures transform data,
and the mesh pulls data (like object color) from its material to draw itself with the shader in the material. Or, we could make this easier and simply
assign the material/shader to the sceneObject itself, and limit sceneObjects to one mesh per SO. 



However, before you do anything else, the mesh should have a name assigned to it when it gets loaded, as a matter of convenience.

I've switched the c++ project over to use Common Language Runtime support (project->settings->general and c++->general)
It's important to note that this adds .Net framework as a dependancy of the c++ dll
Ergo, it CANNOT run on android in this state

So we treat it as if in dev mode.

TODO: Create a project called ImpunityEngine.Core
Which will store all the classes a user needs to avoid circular dependancies

key words:

create - creates a SceneObject, Light, or Model (as a sceneObject)
setPosition - sets the position of a SceneObject or Light by name or ID
setambient/setamb - id vec3 lightType
list sceneObj/lightType -print a list of objects
setAmbient - set ambient value
setDiffuse - set diffuse value
setSpecular  - set specular value
setMaxDistance - set max distance of light
cutOff  - set the angle of a spotlight
enable - enabled/disable a so/light
list - list a type sceneObject
save - save the scene with a name
scene/load - load scene from a directory
quit - quit the editor
select - select an object by index and type
 r axis degree - rotate an object x degrees around axis axis
 g axis dist - grab and object dist units of dist along axis axis
 tile x y - tile the textures on the material
 offset x y - offset the textures on the material
 swapdiffuse x- swap diffuse map with a texture of id x
 mat amb/diff/spec value - set the color of a particular channel
 mat shine - set shininess of material



 TODO: give key input to c# in the form of an array of ints, each of which corresponds to a value in an enum

 TODO: End dependance on the built-in camera script by giving control to c# class

 DONE: Load scenes from the topmost layer.
	-Impunity classes must be divested of their cyclical SceneObject property!

TODO: setRotation - sets the rotation of a sceneObject or Light by name/ID
TODO:  start, pause, and take off impunityClasses

TODO: Buttons, text, textfields, general GUI-ndc stuff
	-Button clicks can be detected by testing mouse coords against area of button


TODO:And perhaps uniforms, too



example 1: create pointLight
example 2: setPosition int(index) Vector3(position)  type(optional)
example 2b: setpos tree -1 6 -2.3
example 3: create model c:\someDirectory\myModel.obj
example 4:setdiff 2 0.6 0.4 0.4 spotlight
example 5: setspecular 1 .8 .8 .8 plight
example 6: enable tree false
example 7: enable 2 true plight



a     b     c     d   
a     d     b    c  
a     c     d     b

b    a     c     d  
b    d     a     c 
b     c    d      a 

c    a     b     d
c    d     a     b
c     b     d      a


a     b     d     c
a     d     c      b
a      c     b     d

b     a     d      c 
b     d      c      a
b     c       a     a

c      a      d     b
c      d      b     a
c       b      a     d










